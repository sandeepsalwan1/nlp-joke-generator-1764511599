/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_TOSAINFERSHAPESPASS
#define GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#define GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#define GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#define GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#define GEN_PASS_DECL_TOSAVALIDATION
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// TosaInferShapesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAINFERSHAPESPASS
std::unique_ptr<::mlir::Pass> createTosaInferShapesPass();
#undef GEN_PASS_DECL_TOSAINFERSHAPESPASS
#endif // GEN_PASS_DECL_TOSAINFERSHAPESPASS
#ifdef GEN_PASS_DEF_TOSAINFERSHAPESPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaInferShapesPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaInferShapesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaInferShapesPassBase;

  TosaInferShapesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaInferShapesPassBase(const TosaInferShapesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaInferShapesPassBase& operator=(const TosaInferShapesPassBase &) = delete;
  TosaInferShapesPassBase(TosaInferShapesPassBase &&) = delete;
  TosaInferShapesPassBase& operator=(TosaInferShapesPassBase &&) = delete;
  ~TosaInferShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-infer-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-infer-shapes"; }

  ::llvm::StringRef getDescription() const override { return "Propagate shapes across TOSA operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaInferShapesPass");
  }
  ::llvm::StringRef getName() const override { return "TosaInferShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaInferShapesPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaInferShapesPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaInferShapesPass() {
  return impl::createTosaInferShapesPass();
}
#undef GEN_PASS_DEF_TOSAINFERSHAPESPASS
#endif // GEN_PASS_DEF_TOSAINFERSHAPESPASS

//===----------------------------------------------------------------------===//
// TosaLayerwiseConstantFoldPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
struct TosaLayerwiseConstantFoldPassOptions {
  bool aggressiveReduceConstant = false;
};
std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass();
std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options);
#undef GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#ifdef GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaLayerwiseConstantFoldPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaLayerwiseConstantFoldPassBase;

  TosaLayerwiseConstantFoldPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaLayerwiseConstantFoldPassBase(const TosaLayerwiseConstantFoldPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaLayerwiseConstantFoldPassBase& operator=(const TosaLayerwiseConstantFoldPassBase &) = delete;
  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassBase &&) = delete;
  TosaLayerwiseConstantFoldPassBase& operator=(TosaLayerwiseConstantFoldPassBase &&) = delete;
  ~TosaLayerwiseConstantFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-layerwise-constant-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-layerwise-constant-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold layerwise operations on constant tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLayerwiseConstantFoldPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLayerwiseConstantFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaLayerwiseConstantFoldPassBase<DerivedT>)

  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassOptions options) : TosaLayerwiseConstantFoldPassBase() {
    aggressiveReduceConstant = std::move(options.aggressiveReduceConstant);
  }
protected:
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc("Always perform the reduce constant optimizationMay add more tosa.const but would reduce runtime calculations"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass() {
  return impl::createTosaLayerwiseConstantFoldPass();
}

std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options) {
  return impl::createTosaLayerwiseConstantFoldPass(std::move(options));
}
#undef GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS

//===----------------------------------------------------------------------===//
// TosaMakeBroadcastablePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass();
#undef GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#ifdef GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaMakeBroadcastablePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaMakeBroadcastablePassBase;

  TosaMakeBroadcastablePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaMakeBroadcastablePassBase(const TosaMakeBroadcastablePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaMakeBroadcastablePassBase& operator=(const TosaMakeBroadcastablePassBase &) = delete;
  TosaMakeBroadcastablePassBase(TosaMakeBroadcastablePassBase &&) = delete;
  TosaMakeBroadcastablePassBase& operator=(TosaMakeBroadcastablePassBase &&) = delete;
  ~TosaMakeBroadcastablePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-make-broadcastable");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-make-broadcastable"; }

  ::llvm::StringRef getDescription() const override { return "TOSA rank Reshape to enable Broadcasting"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaMakeBroadcastablePass");
  }
  ::llvm::StringRef getName() const override { return "TosaMakeBroadcastablePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaMakeBroadcastablePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass() {
  return impl::createTosaMakeBroadcastablePass();
}
#undef GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS

//===----------------------------------------------------------------------===//
// TosaOptionalDecompositionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass();
#undef GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#ifdef GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaOptionalDecompositionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaOptionalDecompositionsPassBase;

  TosaOptionalDecompositionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaOptionalDecompositionsPassBase(const TosaOptionalDecompositionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaOptionalDecompositionsPassBase& operator=(const TosaOptionalDecompositionsPassBase &) = delete;
  TosaOptionalDecompositionsPassBase(TosaOptionalDecompositionsPassBase &&) = delete;
  TosaOptionalDecompositionsPassBase& operator=(TosaOptionalDecompositionsPassBase &&) = delete;
  ~TosaOptionalDecompositionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-optional-decompositions");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-optional-decompositions"; }

  ::llvm::StringRef getDescription() const override { return "Applies Tosa operations optional decompositions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaOptionalDecompositionsPass");
  }
  ::llvm::StringRef getName() const override { return "TosaOptionalDecompositionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaOptionalDecompositionsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass() {
  return impl::createTosaOptionalDecompositionsPass();
}
#undef GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS

//===----------------------------------------------------------------------===//
// TosaReduceTransposes
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAREDUCETRANSPOSES
std::unique_ptr<::mlir::Pass> createTosaReduceTransposes();
#undef GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#ifdef GEN_PASS_DEF_TOSAREDUCETRANSPOSES

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaReduceTransposes();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaReduceTransposesBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaReduceTransposesBase;

  TosaReduceTransposesBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaReduceTransposesBase(const TosaReduceTransposesBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaReduceTransposesBase& operator=(const TosaReduceTransposesBase &) = delete;
  TosaReduceTransposesBase(TosaReduceTransposesBase &&) = delete;
  TosaReduceTransposesBase& operator=(TosaReduceTransposesBase &&) = delete;
  ~TosaReduceTransposesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-reduce-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-reduce-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Reduce transposes through other operators"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaReduceTransposes");
  }
  ::llvm::StringRef getName() const override { return "TosaReduceTransposes"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaReduceTransposesBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaReduceTransposes() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaReduceTransposes() {
  return impl::createTosaReduceTransposes();
}
#undef GEN_PASS_DEF_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_DEF_TOSAREDUCETRANSPOSES

//===----------------------------------------------------------------------===//
// TosaValidation
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAVALIDATION
struct TosaValidationOptions {
  ::llvm::SmallVector<std::string> profile;
  ::llvm::SmallVector<std::string> extension;
  bool strictOpSpecAlignment = false;
  bool allowInvalidOpDatatypeCombinations = false;
  mlir::tosa::TosaLevelEnum level = mlir::tosa::TosaLevelEnum::EightK;
};
std::unique_ptr<::mlir::Pass> createTosaValidation();
std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options);
#undef GEN_PASS_DECL_TOSAVALIDATION
#endif // GEN_PASS_DECL_TOSAVALIDATION
#ifdef GEN_PASS_DEF_TOSAVALIDATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaValidation();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaValidationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TosaValidationBase;

  TosaValidationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaValidationBase(const TosaValidationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TosaValidationBase& operator=(const TosaValidationBase &) = delete;
  TosaValidationBase(TosaValidationBase &&) = delete;
  TosaValidationBase& operator=(TosaValidationBase &&) = delete;
  ~TosaValidationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-validate");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-validate"; }

  ::llvm::StringRef getDescription() const override { return "Validates TOSA dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaValidation");
  }
  ::llvm::StringRef getName() const override { return "TosaValidation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaValidationBase<DerivedT>)

  TosaValidationBase(TosaValidationOptions options) : TosaValidationBase() {
    profile = std::move(options.profile);
    extension = std::move(options.extension);
    strictOpSpecAlignment = std::move(options.strictOpSpecAlignment);
    allowInvalidOpDatatypeCombinations = std::move(options.allowInvalidOpDatatypeCombinations);
    level = std::move(options.level);
  }
protected:
  ::mlir::Pass::ListOption<std::string> profile{*this, "profile", ::llvm::cl::desc("Validate if operations match for the given profile set")};
  ::mlir::Pass::ListOption<std::string> extension{*this, "extension", ::llvm::cl::desc("Validate if operations match for the given extension set")};
  ::mlir::Pass::Option<bool> strictOpSpecAlignment{*this, "strict-op-spec-alignment", ::llvm::cl::desc("Verify if the properties of certain operations align the spec requirement"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowInvalidOpDatatypeCombinations{*this, "allow-invalid-op-datatype-combinations", ::llvm::cl::desc("Disable checks for operations that are determined to be invalid due to their operand/result datatypes not aligning with the 'Supported Data Types' sections of the specifciation"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<mlir::tosa::TosaLevelEnum> level{*this, "level", ::llvm::cl::desc("Validate if operator parameters are within specfication for the given level"), ::llvm::cl::init(mlir::tosa::TosaLevelEnum::EightK), ::llvm::cl::values(
               clEnumValN(mlir::tosa::TosaLevelEnum::EightK, "8k",
                "Ranges are expected to be sufficient for applications with frame sizes up to 8K."),
               clEnumValN(mlir::tosa::TosaLevelEnum::None, "none",
                "Allows the full range of arguments specified by the operations according "
                "to the operation data types.")
              )};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaValidation() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaValidation() {
  return impl::createTosaValidation();
}

std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options) {
  return impl::createTosaValidation(std::move(options));
}
#undef GEN_PASS_DEF_TOSAVALIDATION
#endif // GEN_PASS_DEF_TOSAVALIDATION
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TosaInferShapesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaInferShapesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaInferShapesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaInferShapesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaInferShapesPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaLayerwiseConstantFoldPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaLayerwiseConstantFoldPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaLayerwiseConstantFoldPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaLayerwiseConstantFoldPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaLayerwiseConstantFoldPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaMakeBroadcastablePass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaMakeBroadcastablePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaMakeBroadcastablePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaMakeBroadcastablePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaMakeBroadcastablePass();
  });
}

//===----------------------------------------------------------------------===//
// TosaOptionalDecompositionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaOptionalDecompositionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaOptionalDecompositionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaOptionalDecompositionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaOptionalDecompositionsPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaReduceTransposes Registration
//===----------------------------------------------------------------------===//

inline void registerTosaReduceTransposes() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaReduceTransposes();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaReduceTransposesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaReduceTransposes();
  });
}

//===----------------------------------------------------------------------===//
// TosaValidation Registration
//===----------------------------------------------------------------------===//

inline void registerTosaValidation() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaValidation();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaValidationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaValidation();
  });
}

//===----------------------------------------------------------------------===//
// TosaOpt Registration
//===----------------------------------------------------------------------===//

inline void registerTosaOptPasses() {
  registerTosaInferShapesPass();
  registerTosaLayerwiseConstantFoldPass();
  registerTosaMakeBroadcastablePass();
  registerTosaOptionalDecompositionsPass();
  registerTosaReduceTransposes();
  registerTosaValidation();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class TosaInferShapesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaInferShapesPassBase;

  TosaInferShapesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaInferShapesPassBase(const TosaInferShapesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaInferShapesPassBase& operator=(const TosaInferShapesPassBase &) = delete;
  TosaInferShapesPassBase(TosaInferShapesPassBase &&) = delete;
  TosaInferShapesPassBase& operator=(TosaInferShapesPassBase &&) = delete;
  ~TosaInferShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-infer-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-infer-shapes"; }

  ::llvm::StringRef getDescription() const override { return "Propagate shapes across TOSA operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaInferShapesPass");
  }
  ::llvm::StringRef getName() const override { return "TosaInferShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaInferShapesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaLayerwiseConstantFoldPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaLayerwiseConstantFoldPassBase;

  TosaLayerwiseConstantFoldPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaLayerwiseConstantFoldPassBase(const TosaLayerwiseConstantFoldPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaLayerwiseConstantFoldPassBase& operator=(const TosaLayerwiseConstantFoldPassBase &) = delete;
  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassBase &&) = delete;
  TosaLayerwiseConstantFoldPassBase& operator=(TosaLayerwiseConstantFoldPassBase &&) = delete;
  ~TosaLayerwiseConstantFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-layerwise-constant-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-layerwise-constant-fold"; }

  ::llvm::StringRef getDescription() const override { return "Fold layerwise operations on constant tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLayerwiseConstantFoldPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLayerwiseConstantFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaLayerwiseConstantFoldPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc("Always perform the reduce constant optimizationMay add more tosa.const but would reduce runtime calculations"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class TosaMakeBroadcastablePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaMakeBroadcastablePassBase;

  TosaMakeBroadcastablePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaMakeBroadcastablePassBase(const TosaMakeBroadcastablePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaMakeBroadcastablePassBase& operator=(const TosaMakeBroadcastablePassBase &) = delete;
  TosaMakeBroadcastablePassBase(TosaMakeBroadcastablePassBase &&) = delete;
  TosaMakeBroadcastablePassBase& operator=(TosaMakeBroadcastablePassBase &&) = delete;
  ~TosaMakeBroadcastablePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-make-broadcastable");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-make-broadcastable"; }

  ::llvm::StringRef getDescription() const override { return "TOSA rank Reshape to enable Broadcasting"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaMakeBroadcastablePass");
  }
  ::llvm::StringRef getName() const override { return "TosaMakeBroadcastablePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaMakeBroadcastablePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaOptionalDecompositionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaOptionalDecompositionsPassBase;

  TosaOptionalDecompositionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaOptionalDecompositionsPassBase(const TosaOptionalDecompositionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaOptionalDecompositionsPassBase& operator=(const TosaOptionalDecompositionsPassBase &) = delete;
  TosaOptionalDecompositionsPassBase(TosaOptionalDecompositionsPassBase &&) = delete;
  TosaOptionalDecompositionsPassBase& operator=(TosaOptionalDecompositionsPassBase &&) = delete;
  ~TosaOptionalDecompositionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-optional-decompositions");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-optional-decompositions"; }

  ::llvm::StringRef getDescription() const override { return "Applies Tosa operations optional decompositions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaOptionalDecompositionsPass");
  }
  ::llvm::StringRef getName() const override { return "TosaOptionalDecompositionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaOptionalDecompositionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaReduceTransposesBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaReduceTransposesBase;

  TosaReduceTransposesBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaReduceTransposesBase(const TosaReduceTransposesBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaReduceTransposesBase& operator=(const TosaReduceTransposesBase &) = delete;
  TosaReduceTransposesBase(TosaReduceTransposesBase &&) = delete;
  TosaReduceTransposesBase& operator=(TosaReduceTransposesBase &&) = delete;
  ~TosaReduceTransposesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-reduce-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-reduce-transposes"; }

  ::llvm::StringRef getDescription() const override { return "Reduce transposes through other operators"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaReduceTransposes");
  }
  ::llvm::StringRef getName() const override { return "TosaReduceTransposes"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaReduceTransposesBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaValidationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TosaValidationBase;

  TosaValidationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaValidationBase(const TosaValidationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TosaValidationBase& operator=(const TosaValidationBase &) = delete;
  TosaValidationBase(TosaValidationBase &&) = delete;
  TosaValidationBase& operator=(TosaValidationBase &&) = delete;
  ~TosaValidationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-validate");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-validate"; }

  ::llvm::StringRef getDescription() const override { return "Validates TOSA dialect"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaValidation");
  }
  ::llvm::StringRef getName() const override { return "TosaValidation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaValidationBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<std::string> profile{*this, "profile", ::llvm::cl::desc("Validate if operations match for the given profile set")};
  ::mlir::Pass::ListOption<std::string> extension{*this, "extension", ::llvm::cl::desc("Validate if operations match for the given extension set")};
  ::mlir::Pass::Option<bool> strictOpSpecAlignment{*this, "strict-op-spec-alignment", ::llvm::cl::desc("Verify if the properties of certain operations align the spec requirement"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowInvalidOpDatatypeCombinations{*this, "allow-invalid-op-datatype-combinations", ::llvm::cl::desc("Disable checks for operations that are determined to be invalid due to their operand/result datatypes not aligning with the 'Supported Data Types' sections of the specifciation"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<mlir::tosa::TosaLevelEnum> level{*this, "level", ::llvm::cl::desc("Validate if operator parameters are within specfication for the given level"), ::llvm::cl::init(mlir::tosa::TosaLevelEnum::EightK), ::llvm::cl::values(
               clEnumValN(mlir::tosa::TosaLevelEnum::EightK, "8k",
                "Ranges are expected to be sufficient for applications with frame sizes up to 8K."),
               clEnumValN(mlir::tosa::TosaLevelEnum::None, "none",
                "Allows the full range of arguments specified by the operations according "
                "to the operation data types.")
              )};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
